import { DocumentItem } from '../model/DocumentItem'
import { DocumentTypeInfo } from '../types/DocumentRecognition'
import { preferences } from '@kit.ArkData'

// å®šä¹‰ JSON æ¥å£
interface DocumentItemJSON {
  id?: string
  name?: string
  type?: string
  number?: string
  expiryDate?: string
  imageUrl?: string
  createTime?: string
  updateTime?: string
  dynamicFields?: Record<string, string>
  recognitionConfidence?: number
  originalImagePath?: string
}

export class LocalDatabaseManager {
  private static readonly DOCUMENTS_KEY = 'documents'
  private static readonly DOCUMENT_TYPES_KEY = 'document_types'
  private static readonly PREFERENCES_NAME = 'document_manager'

  private static instance: LocalDatabaseManager
  private preferencesHelper: preferences.Preferences | null = null

  private constructor() {}

  static getInstance(): LocalDatabaseManager {
    if (!LocalDatabaseManager.instance) {
      LocalDatabaseManager.instance = new LocalDatabaseManager()
    }
    return LocalDatabaseManager.instance
  }

  // åˆå§‹åŒ–æ•°æ®åº“
  async initialize(context: Context): Promise<void> {
    try {
      this.preferencesHelper = await preferences.getPreferences(context, LocalDatabaseManager.PREFERENCES_NAME)
      console.log('æœ¬åœ°æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ')
    } catch (error) {
      console.error('æœ¬åœ°æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error)
    }
  }

  // ä¿å­˜æ–‡æ¡£åˆ—è¡¨
  async saveDocuments(documents: DocumentItem[]): Promise<boolean> {
    try {
      if (!this.preferencesHelper) {
        console.error('æ•°æ®åº“æœªåˆå§‹åŒ–')
        return false
      }

      const documentsJSON = documents.map(doc => doc.toJSON())
      await this.preferencesHelper.put(LocalDatabaseManager.DOCUMENTS_KEY, JSON.stringify(documentsJSON))
      await this.preferencesHelper.flush()
      
      // æ›´æ–°æ–‡æ¡£ç±»å‹ç»Ÿè®¡
      await this.updateDocumentTypes(documents)
      
      console.log('æ–‡æ¡£ä¿å­˜æˆåŠŸï¼Œå…±ä¿å­˜', documents.length, 'ä¸ªæ–‡æ¡£')
      return true
    } catch (error) {
      console.error('ä¿å­˜æ–‡æ¡£å¤±è´¥:', error)
      return false
    }
  }

  // åŠ è½½æ–‡æ¡£åˆ—è¡¨
  async loadDocuments(): Promise<DocumentItem[]> {
    try {
      if (!this.preferencesHelper) {
        console.error('æ•°æ®åº“æœªåˆå§‹åŒ–')
        return []
      }

      const documentsJSON = await this.preferencesHelper.get(LocalDatabaseManager.DOCUMENTS_KEY, '[]')
      const documentsArray = JSON.parse(documentsJSON as string) as DocumentItemJSON[]

      const documents = documentsArray.map((json) => {
        const dynamicFields = new Map<string, string>()
        if (json.dynamicFields) {
          Object.keys(json.dynamicFields).forEach(key => {
            dynamicFields.set(key, json.dynamicFields![key])
          })
        }

        const item = new DocumentItem(
          json.id || '',
          json.name || '',
          json.type || '',
          json.number || '',
          json.expiryDate || '',
          json.imageUrl || '',
          new Date(json.createTime || Date.now()),
          new Date(json.updateTime || Date.now()),
          dynamicFields,
          json.recognitionConfidence || 0,
          json.originalImagePath || ''
        )
        return item
      })

      console.log('æ–‡æ¡£åŠ è½½æˆåŠŸï¼Œå…±åŠ è½½', documents.length, 'ä¸ªæ–‡æ¡£')
      return documents
    } catch (error) {
      console.error('åŠ è½½æ–‡æ¡£å¤±è´¥:', error)
      return []
    }
  }

  // æ·»åŠ å•ä¸ªæ–‡æ¡£
  async addDocument(document: DocumentItem): Promise<boolean> {
    try {
      const documents = await this.loadDocuments()
      documents.push(document)
      return await this.saveDocuments(documents)
    } catch (error) {
      console.error('æ·»åŠ æ–‡æ¡£å¤±è´¥:', error)
      return false
    }
  }

  // æ›´æ–°å•ä¸ªæ–‡æ¡£
  async updateDocument(document: DocumentItem): Promise<boolean> {
    try {
      const documents = await this.loadDocuments()
      const index = documents.findIndex(doc => doc.id === document.id)
      if (index !== -1) {
        documents[index] = document
        return await this.saveDocuments(documents)
      }
      return false
    } catch (error) {
      console.error('æ›´æ–°æ–‡æ¡£å¤±è´¥:', error)
      return false
    }
  }

  // åˆ é™¤å•ä¸ªæ–‡æ¡£
  async deleteDocument(id: string): Promise<boolean> {
    try {
      const documents = await this.loadDocuments()
      const filteredDocuments = documents.filter(doc => doc.id !== id)
      return await this.saveDocuments(filteredDocuments)
    } catch (error) {
      console.error('åˆ é™¤æ–‡æ¡£å¤±è´¥:', error)
      return false
    }
  }

  // æ ¹æ®IDè·å–æ–‡æ¡£
  async getDocumentById(id: string): Promise<DocumentItem | null> {
    try {
      const documents = await this.loadDocuments()
      return documents.find(doc => doc.id === id) || null
    } catch (error) {
      console.error('è·å–æ–‡æ¡£å¤±è´¥:', error)
      return null
    }
  }

  // æ ¹æ®ç±»å‹è·å–æ–‡æ¡£
  async getDocumentsByType(type: string): Promise<DocumentItem[]> {
    try {
      const documents = await this.loadDocuments()
      if (type === 'å…¨éƒ¨') {
        return documents
      }
      return documents.filter(doc => doc.type === type)
    } catch (error) {
      console.error('æ ¹æ®ç±»å‹è·å–æ–‡æ¡£å¤±è´¥:', error)
      return []
    }
  }

  // æœç´¢æ–‡æ¡£
  async searchDocuments(keyword: string): Promise<DocumentItem[]> {
    try {
      const documents = await this.loadDocuments()
      return documents.filter(doc => 
        doc.name.includes(keyword) || 
        doc.number.includes(keyword) ||
        doc.type.includes(keyword)
      )
    } catch (error) {
      console.error('æœç´¢æ–‡æ¡£å¤±è´¥:', error)
      return []
    }
  }

  // æ›´æ–°æ–‡æ¡£ç±»å‹ç»Ÿè®¡
  private async updateDocumentTypes(documents: DocumentItem[]): Promise<void> {
    try {
      const typeCount = new Map<string, number>()
      
      // ç»Ÿè®¡å„ç±»å‹æ–‡æ¡£æ•°é‡
      documents.forEach(doc => {
        const count = typeCount.get(doc.type) || 0
        typeCount.set(doc.type, count + 1)
      })

      // è½¬æ¢ä¸ºDocumentTypeInfoæ•°ç»„
      const documentTypes: DocumentTypeInfo[] = []
      typeCount.forEach((count, type) => {
        documentTypes.push({
          type,
          displayName: type,
          icon: this.getDocumentTypeIcon(type),
          count
        })
      })

      // ä¿å­˜æ–‡æ¡£ç±»å‹ä¿¡æ¯
      if (this.preferencesHelper) {
        await this.preferencesHelper.put(LocalDatabaseManager.DOCUMENT_TYPES_KEY, JSON.stringify(documentTypes))
        await this.preferencesHelper.flush()
      }
    } catch (error) {
      console.error('æ›´æ–°æ–‡æ¡£ç±»å‹ç»Ÿè®¡å¤±è´¥:', error)
    }
  }

  // è·å–æ–‡æ¡£ç±»å‹åˆ—è¡¨
  async getDocumentTypes(): Promise<DocumentTypeInfo[]> {
    try {
      if (!this.preferencesHelper) {
        return []
      }

      const typesJSON = await this.preferencesHelper.get(LocalDatabaseManager.DOCUMENT_TYPES_KEY, '[]')
      const types = JSON.parse(typesJSON as string) as DocumentTypeInfo[]
      return types
    } catch (error) {
      console.error('è·å–æ–‡æ¡£ç±»å‹å¤±è´¥:', error)
      return []
    }
  }

  // è·å–æ–‡æ¡£ç±»å‹å›¾æ ‡
  private getDocumentTypeIcon(type: string): string {
    const iconMap: Record<string, string> = {
      'èº«ä»½è¯': 'ğŸ†”',
      'æŠ¤ç…§': 'ğŸ“˜',
      'é©¾é©¶è¯': 'ğŸš—',
      'é“¶è¡Œå¡': 'ğŸ’³',
      'å…¶ä»–': 'ğŸ“„'
    }
    const icon = iconMap[type]
    return icon || 'ğŸ“„'
  }

  // æ¸…ç©ºæ‰€æœ‰æ•°æ®
  async clearAllData(): Promise<boolean> {
    try {
      if (!this.preferencesHelper) {
        return false
      }

      await this.preferencesHelper.clear()
      await this.preferencesHelper.flush()
      console.log('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º')
      return true
    } catch (error) {
      console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error)
      return false
    }
  }
}
